package trafficsimulator.shared.dto;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import lombok.Getter;
import lombok.Setter;
import trafficsimulator.shared.enumerators.VehicleTypeEnum;
import trafficsimulator.shared.exceptions.InfrastructureElementNotFoundException;


/**
 * Class represents complete configuration of simulated situation
 * 
 * @author z003ru0y
 *
 */
public class Situation
{

  @Getter
  private List<Intersection> intersectionList;

  /* list of routes which are used for generating the flows file */
  @Getter
  @Setter
  private List<Flow> routes;

  /* list of routes generated by duarouter and used for routes file */
  @Getter
  @Setter
  private List<GeneratedRoute> generatedRoutes;

  /* list of connecting edges between intersections */
  @Getter
  private List<IntersectionConnection> intersectionConnections;

  /* set vehicle types in the simulation */
  @Getter
  private List<VehicleType> vehicleTypes;

  /**
   * inits empty situation
   */
  public Situation()
  {
    this.intersectionList = new ArrayList<>();
    this.intersectionConnections = new ArrayList<>();
    this.routes = new ArrayList<>();
    this.vehicleTypes = new ArrayList<>();
  }
  
  /**
   * @return intersection id based on already existing ids
   */
  public int generateIntersectionId()
  {
    if (intersectionList.isEmpty())
    {
      return 0;
    }
    else
    {
      final Comparator<Intersection> comp = (p1, p2) -> Integer.compare(p1.getId(), p2.getId());
      return intersectionList.stream().max(comp).get().getId() + 1;
    }
  }

  /**
   * @param intersection adds intersection to situation
   */
  public void addIntersection(Intersection intersection)
  {
    intersectionList.add(intersection);
  }
  
  /**
   * @param connection adds intersection connection to situation
   */
  public void addIntersectionConnection(IntersectionConnection connection)
  {
    intersectionConnections.add(connection);
  }

  /**
   * Removes intersection and all of its connections
   * @param id id of deleted intersection
   * @throws InfrastructureElementNotFoundException when the intersection is not found
   */
  public void deleteIntersection(int id) 
      throws InfrastructureElementNotFoundException
  {
    Intersection intersection = getIntersectionById(id);
    
    List<IntersectionConnection> toRemove = new ArrayList<>();
    
    for (IntersectionConnection connection : getIntersectionConnections())
    {
      if (id == connection.getIntersection1().getId() || id == connection.getIntersection2().getId())
      {
        toRemove.add(connection);
      }
    }
    
    for (IntersectionConnection connection : toRemove)
    {
      intersectionConnections.remove(connection);
    }
    
    if (intersection != null)
    {
      this.intersectionList.remove(intersection);
    }
    
  }  

  /**
   * @param id id of searched intersection
   * @return found intersection
   * @throws InfrastructureElementNotFoundException when the intersection is not found
   */
  public Intersection getIntersectionById(int id) throws InfrastructureElementNotFoundException
  {
    for (Intersection intersection : this.getIntersectionList())
    {
      if (id == intersection.getId())
      {
        return intersection;
      }
    }    
    throw new InfrastructureElementNotFoundException("Intersection by ID: " + id);
  }

  /**
   * Retrieves all detectors from the infrastructure
   * @return list of detector DTOs
   */
  public List<Detector> getAllDetectors()
  {
    List<Detector> allDetectors = new ArrayList<>();
    intersectionList.forEach(
      i -> allDetectors.addAll(i.getAllDetectors()));
    return allDetectors;
  }



  /**
   * Sets the vehicle types to the situation
   * @param vehicleType enum of the added vehicle type
   */
  public void setVehicleType(VehicleTypeEnum vehicleType)
  {    
    switch (vehicleType)
    {
      case VAN:
        this.vehicleTypes.add(new VehicleType(vehicleType, 2.5, 6.0, 7.5));
        break;
      case BUS_PUBLIC:
        this.vehicleTypes.add(new VehicleType(vehicleType, 2.2, 6.0, 9));
        break;
      case BUS_PRIVATE:
        this.vehicleTypes.add(new VehicleType(vehicleType, 2.2, 6.0, 9));
        break;
      case TRUCK:
        this.vehicleTypes.add(new VehicleType(vehicleType, 2.0, 5.0, 9));
        break;
      default:
        this.vehicleTypes.add(new VehicleType(vehicleType, 2.6, 7.0, 5.5));
        break;
    }    
  }
 
  @Override
  public String toString()
  {
    return intersectionList.toString() + "\n";
  }

}
